Общее описание проекта и процесса разработки

# Rubas

## Аннотация

Приводится детальное описание проекта и его ключевых (технологических) особенностей, а также особенностей 
процесса разработки.

## Технологические сведения

### Стек используемых библиотек и фреймворков

В проекте используется стек - Ant Design (UI) + Icons, wagmi + viem (Web3), zustand (стейт), i18next + react-i18next
(i18n), loglevel (логирование):

**UI**: реализован на основе Ant Design + Icons (позволяет реализовать единый стиль и поддержку тем).

**Web3**: реализуется через связку wagmi + viem (удобные хуки для работы с кошельками, контрактами, сетями, 
а также для подписания транзакций).

**Управление состоянием**: zustand - минималистичный state-менеджер, для хранения пользовательских данных, состояния 
кошелька, UI-состояния.

**Интернационализация**: i18next + react-i18next.

**Логирование**: loglevel - легковесное и настраиваемое решение для логирования, достаточно для любого масштаба приложения.

Конкретные версии представлены в следующей таблице:

| Категория            | Технологии                  | Пакеты (версии)                                                                          |
|----------------------|-----------------------------|------------------------------------------------------------------------------------------|
| **UI Framework**     | Ant Design + Icons          | `antd` (5.24.9), `@ant-design/icons` (6.0.0)                                             |
| **Web3**             | Wagmi + Viem                | `wagmi` (2.15.2), `viem` (2.28.4)                                                        |
| **State Management** | Zustand + React Context     | `zustand` (5.0.4), `use-sync-external-store` (1.5.0)                                     |
| **i18n**             | i18next + React Integration | `i18next` (25.0.2), `react-i18next` (15.5.1), `i18next-browser-languagedetector` (8.1.0) |
| **Utilities**        | React Hooks Collection      | `react-use` (17.6.0)                                                                     |
| **Логирование**      | loglevel                    | `loglevel` (1.9.2)                                                                       |

### Стек инструментов разработки

| Категория               | Инструменты / Конфигурации                                                  |
|-------------------------|-----------------------------------------------------------------------------|
| **Bundler**             | `Vite` (6.3.5)                                                              |
| **Linting**             | - `ESLint` (9.26.0) с плагинами:                                            |
|                         | - `@typescript-eslint/eslint-plugin` (8.32.0)                               |
|                         | - `eslint-plugin-import` (2.31.0)                                           |
|                         | - `eslint-plugin-prettier` (5.4.0)                                          |
|                         | - `eslint-plugin-react-hooks` (5.2.0)                                       |
|                         | - `eslint-plugin-react-refresh` (0.4.19)                                    |
|                         | - `eslint-plugin-simple-import-sort` (12.1.1)                               |
| **Форматирование кода** | `Prettier` (3.5.3) с конфигурацией `eslint-config-prettier` (10.1.3)        |
| **Type Checking**       | `TypeScript` (5.8.3) + `@types/react` (19.1.2), `@types/react-dom` (19.1.2) |
| **React Runtime**       | `@vitejs/plugin-react` (4.4.1)                                              |
| **SCSS**                | `sass` (1.87.0)                                                             |
| **Node.js**             | v22.13.1                                                                    |

Кроме того, для разрабатываемых компонент имеется Storybook, позволяющий проверить и протестировать компоненты по
отдельности.

### Требования к процессу разработки

Общие требования заключаются в том, чтобы обеспечивать модульность, слабую связанность и "чистую" архитектуру, а 
также поддерживаемость, тестируемость и расширяемость кода.

При написании нового кода необходимо следовать этим рекомендациям:
1. Применять подход «атомарного дизайна» (Atomic Design): atoms → molecules → organisms.
2. Учитывать разбиение на слои:
   * components/ — визуальные компоненты (атомы, молекулы, организмы).
   * hooks/ — бизнес-логика в виде хуков (useWallet, useTokenBalance).
   * services/ — работа с Web3, провайдерами, форматированием отображаемых данных и т.д..
   * context/ — хранение и распространение глобального состояния.
3. Соблюдать следующие правила:
   * UI-компоненты должны поддерживать:
     - собственные (обособленные) стили в форме scss;  
     - локализацию через i18n;
     - логирование.
   * При этом бизнес-логика должна быть вынесена из UI-компонентов (ее следует описывать в виде хуков).
   * Код компонентов должен быть документирован в стиле JSDoc. Кроме того, первая строка всегда должна содержать 
     однострочный комментарий, который должен быть использован при суммаризации проекта (в этом комментарии очень-очень 
     кратко должна передаваться основная суть). Опционально: по тексту компонента можно добавлять краткие комментарии, 
     если это будет способствовать лучшему пониманию кода.
   * Следует использовать args для передачи пропсов ("пробрасывать" пропсы).
   * Все пропсы и/или параметры должны быть описаны в JSDocs ()
   * Следует всегда прямо и явно указывать все типы (для пропсов, для компонентов и т.д.).
   * Каждый компонент должен быть снабжен историей для Stroybook и минимальным набором тестов (файл *.stories.tsx 
     должен быть в той же папке, что и сам компонент).

### Система оценки готовности кода

Код оценивается в виде звезд. Оценка выставляется в однострочном комментарии (в квадратных скобках).

* ☆☆☆☆☆ — PoC (первый вариант написания кода, к которому предъявляется только требование работоспособности)
* ★☆☆☆☆ — имеются комментарии: однострочный, JSDoc, и опционально также минимальные комментарии по тексту
* ★★☆☆☆ — всё перечисленное + отсутствуют замечания со стороны линтера
* ★★★☆☆ — всё перечисленное + оптимизированы и упорядочены импорты
* ★★★★☆ — всё перечисленное + выполнено ревью кода
* ★★★★★ — всё перечисленное + имеются истории для Сторибука и тесты

### Управление изменениями репозитория

Применяется упрощенный flow (с feature-ветками). Такой подход позволяет, с одной стороны, избежать избыточных
сложностей, а с другой - оберегать имеющийся код от разрушения при работе над новой функциональностью. В рамках этого
flow предполагается выполнение следующих действий:

1. Переключиться на основную ветку и обновить её:
``` 
git checkout master
git pull master
```

2. Создать новую ветку для задачи c использованием следующих префиксов `feature/`, `bugfix/`, `docs/`, `chore/` (об
   именовании веток - см. следующий раздел):
```
git checkout -b feature/some-branch-name
```

3. Внести изменения.

4. Добавить файлы в индекс и выполнить коммит:
```
git add ***
git commit -m "Описание изменений"
```

5. Переключиться на основную ветку:
   
```
git checkout master
```

6. Объединить ветки:

```
git merge feature/some-branch-name
```

7. _Опционально_: отправить изменения на удалённый репозиторий:
```
git push master
```

8. _Опционально_: удалить ненужную ветку.

### Именование веток репозитория

Для веток следует выбирать имена, начинающиеся со следующих префиксов:

* feature/ - добавление нового функционала;
* bugfix/ - исправление ошибки;
* docs/ - если это чисто документация (очень популярный префикс для таких задач);
* chore/ - если это техническое изменение, не влияющее на функционал.